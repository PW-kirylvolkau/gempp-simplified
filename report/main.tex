\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel} % albo [polish], jeśli raport ma być po polsku
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{geometry}
\geometry{margin=2.5cm}

\title{Graph Distance and Minimal Extension\\
  \large Algorithms and Computability – Project Report}
\author{Borkowicz Dominik \and Volkau Kiryl \and Włodarczyk Wiktoria }
\date{\today}

\begin{document}

\maketitle

\section{Introduction}


\section{Preliminaries and Definitions}

We begin by specifying our graph model and by introducing the key concepts used throughout the report: graph size, a distance function on graphs, graph and subgraph isomorphism, and the minimal extension problem.

\subsection{Graph Model and Input Format}

In this project we work with finite, simple graphs.
A graph is a pair $G = (V,E)$, where $V$ is a finite set of vertices and $E \subseteq \{\{u,v\} \mid u,v \in V, u \neq v\}$ is a set of undirected edges.
We do not allow parallel edges or self-loops.
The methods considered in this report can be extended to other graph models (directed graphs, multigraphs).

We represent graphs by adjacency matrices.
Let $G = (V,E)$ with $V = \{1,\dots,n\}$.
The adjacency matrix $A \in \{0,1\}^{n \times n}$ of $G$ is defined by
\[
  A_{ij} =
  \begin{cases}
    1 & \text{if } \{i,j\} \in E,\\
    0 & \text{otherwise.}
  \end{cases}
\]
For undirected graphs the matrix is symmetric, $A_{ij} = A_{ji}$, and the diagonal entries are zero.



\subsection{Size of a Graph}

The notion of ``size'' of a graph is not uniquely fixed in the literature and may depend on the application.
For our purposes we define the size of a graph $G = (V,E)$ as
\[
  \mathrm{size}(G) = |V| + |E|.
\]

This definition has several desirable properties:
\begin{itemize}
  \item It takes into account both the number of objects (vertices) and the number of relationships (edges) in the graph.
  \item It is monotone with respect to adding vertices or edges: if $H$ is obtained from $G$ by adding vertices and/or edges, then $\mathrm{size}(H) \geq \mathrm{size}(G)$.
  \item It is linear in the natural parameters $|V|$ and $|E|$, which makes it convenient as a measure of input size in complexity analysis.
\end{itemize}
We use $\mathrm{size}(G)$ as a basic measure of the complexity of a single graph, and pairs such as $(\mathrm{size}(G), \mathrm{size}(H))$ as a measure of the size of an instance of our problems.

\subsection{Graph Edit Distance as a Metric}

Intuitively, the distance between two graphs should quantify how many modifications are needed to transform one graph into the other.
A standard notion capturing this idea is the \emph{graph edit distance} (GED) \cite{riesen2009,lerougeBLP}.
It is defined in terms of elementary edit operations on graphs.

We consider the following edit operations:
\begin{itemize}
  \item vertex insertion,
  \item vertex deletion,
  \item edge insertion,
  \item edge deletion.
\end{itemize}
Each operation has an associated non-negative cost.
In our setting we assume unit costs for all operations, but more general cost functions are possible.

An \emph{edit path} from a graph $G$ to a graph $H$ is a finite sequence of edit operations that transforms $G$ into $H$.
The cost of an edit path is the sum of the costs of its operations.
The graph edit distance between $G$ and $H$ is defined as
\[
  \mathrm{GED}(G,H) = \min \{ \mathrm{cost}(P) \mid P \text{ is an edit path from $G$ to $H$} \}.
\]

Under mild assumptions on the cost function (in particular, non-negativity and symmetry of insertion and deletion costs), GED satisfies the axioms of a metric on the space of graphs:
\begin{itemize}
  \item $\mathrm{GED}(G,H) \geq 0$ and $\mathrm{GED}(G,H) = 0$ if and only if $G$ and $H$ are isomorphic,
  \item $\mathrm{GED}(G,H) = \mathrm{GED}(H,G)$,
  \item $\mathrm{GED}(G,K) \leq \mathrm{GED}(G,H) + \mathrm{GED}(H,K)$ (triangle inequality).
\end{itemize}
We therefore use GED as a reasonable and well-established distance measure between graphs.

\subsection{Graph and Subgraph Isomorphism}

Two graphs $G = (V_G,E_G)$ and $H = (V_H,E_H)$ are \emph{isomorphic} if there exists a bijection
$f : V_G \to V_H$ such that
\[
  \{u,v\} \in E_G \quad \Longleftrightarrow \quad \{f(u), f(v)\} \in E_H
  \quad \text{for all } u,v \in V_G.
\]
Intuitively, isomorphic graphs have the same structure, differing only by the naming of vertices.

A graph $G$ is \emph{isomorphic to a subgraph} of $H$ if there exists an injective mapping
$f : V_G \to V_H$ such that
\[
  \{u,v\} \in E_G \quad \Longrightarrow \quad \{f(u), f(v)\} \in E_H
  \quad \text{for all } u,v \in V_G.
\]
In this case $H$ is said to \emph{contain} $G$ as a subgraph.
The subgraph isomorphism problem---deciding whether such an injective mapping exists---is a classical NP-complete problem.

There is a close connection between graph edit distance and (sub)graph isomorphism.
In particular, if the edit operations are restricted to vertex and edge relabellings and the cost of deletions and insertions is sufficiently large, then $\mathrm{GED}(G,H) = 0$ if and only if $G$ and $H$ are isomorphic.
Similarly, if only insertion operations are allowed, GED reduces to a measure of how far a graph is from containing another as a subgraph.

\subsection{Minimal Extension Problem}

We are now ready to formalize the main problem studied in this project.
Let $G$ and $H$ be two graphs.
We say that a graph $H'$ is an \emph{extension} of $H$ if $H$ is a subgraph of $H'$, that is, $V(H) \subseteq V(H')$ and $E(H) \subseteq E(H')$.

Given a pattern graph $G$, a base graph $H$, and an integer $k \geq 1$, the \emph{minimal extension problem} is defined as follows:
find an extension $H'$ of $H$ such that
\begin{itemize}
  \item $H'$ contains at least $k$ subgraphs that are isomorphic to $G$, and
  \item the number of vertices and edges added to $H$ to obtain $H'$ is minimal.
\end{itemize}
Equivalently, we seek an extension $H'$ minimizing the quantity
\[
  \Delta(H,H') = (|V(H')| - |V(H)|) + (|E(H')| - |E(H)|)
\]
subject to the constraint that $H'$ contains at least $k$ subgraphs isomorphic to $G$.

This problem can be viewed as a constrained variant of graph edit distance, where we allow only insertion operations and require the extended graph to contain a prescribed number of occurrences of a given pattern.

\section{Exact Algorithms}

In this section we describe exact algorithms for the problems introduced above.
We first discuss exact computation of the graph edit distance based on formulations proposed in the literature, and then we outline an exact approach to the minimal extension problem via exhaustive search of subgraph isomorphisms.
In both cases the algorithms have exponential worst-case complexity, which motivates the approximate methods presented in Section~\ref{sec:approx}.
 
\subsection{Exact Graph Edit Distance}
\label{subsec:exact-ged}

Exact computation of the graph edit distance is NP-hard in general and can be approached via binary linear programming (BLP).
In our implementation we follow the \emph{F2} formulation of Lerouge et al.\ \cite{lerougeBLP}, which is a reduced-size exact formulation compared to the straightforward model (\emph{F1}).

Let $G_1=(V_1,E_1)$ and $G_2=(V_2,E_2)$ be two graphs.
The formulation introduces two families of binary substitution variables:
\begin{itemize}
  \item $x_{i,k}\in\{0,1\}$ for $(i,k)\in V_1\times V_2$, where $x_{i,k}=1$ means that vertex $i$ is substituted (matched) with vertex $k$;
  \item $y_{e,f}\in\{0,1\}$ for $(e,f)\in E_1\times E_2$, where $y_{e,f}=1$ means that edge $e$ is substituted with edge $f$.
\end{itemize}
Deletion and insertion operations are handled implicitly: instead of explicit delete/insert variables, \emph{F2} uses a constant term corresponding to deleting and inserting all vertices and edges, and then subtracts the savings obtained by choosing substitutions.
Concretely, the objective has the form
\[
  \min_{x,y}\;\; C
  + \sum_{i\in V_1}\sum_{k\in V_2}\bigl(c_V(i\!\rightarrow\! k)-c_V(i\!\rightarrow\!\epsilon)-c_V(\epsilon\!\rightarrow\! k)\bigr)\,x_{i,k}
  + \sum_{e\in E_1}\sum_{f\in E_2}\bigl(c_E(e\!\rightarrow\! f)-c_E(e\!\rightarrow\!\epsilon)-c_E(\epsilon\!\rightarrow\! f)\bigr)\,y_{e,f},
\]
where $C = \sum_{i\in V_1}c_V(i\!\rightarrow\!\epsilon)+\sum_{k\in V_2}c_V(\epsilon\!\rightarrow\! k)+\sum_{e\in E_1}c_E(e\!\rightarrow\!\epsilon)+\sum_{f\in E_2}c_E(\epsilon\!\rightarrow\! f)$.
With unit insertion/deletion costs (our setting for unlabeled graphs), this simplifies to $C = |V_1|+|V_2|+|E_1|+|E_2|$.

The constraints enforce a one-to-one (partial) vertex assignment, a one-to-one edge assignment, and \emph{topological consistency} between the chosen vertex and edge substitutions.
The assignment constraints are:
\[
  \sum_{k\in V_2} x_{i,k} \le 1 \quad \forall i\in V_1,
  \qquad
  \sum_{i\in V_1} x_{i,k} \le 1 \quad \forall k\in V_2,
\]
and analogously for $y$ over $E_1$ and $E_2$.
The key reduction of \emph{F2} is to replace the quadratic number of edge-to-vertex compatibility constraints (one per pair of edges) by aggregated constraints indexed by vertices of $G_2$ (see \cite{lerougeBLP}).
For undirected graphs, this can be expressed as:
\[
  \sum_{f\in E_2:\; k\in f} y_{\{i,j\},f} \le x_{i,k}+x_{j,k}
  \qquad \forall \{i,j\}\in E_1,\; \forall k\in V_2.
\]

Solving this integer linear program yields an optimal edit path cost and therefore the exact value of $\mathrm{GED}(G_1,G_2)$.
The worst-case time complexity remains exponential (integer programming is NP-hard), but the reduced size of \emph{F2} makes it significantly more practical than the straightforward formulation for small and medium instances.

\subsection{Exact Subgraph Isomorphism and Minimal Extension}
\label{subsec:exact-extension}

We now turn to the minimal extension problem.
Recall that we are given a pattern graph $G$ and a base graph $H$, and we seek an extension $H'$ of $H$ that contains at least one subgraph isomorphic to $G$ while minimizing the number of added vertices and edges.

A conceptually simple exact algorithm is based on enumerating all injective mappings from the vertices of $G$ to the vertices of $H$ (and possibly to new vertices to be added) and computing, for each mapping, the minimal set of edges that must be added so that the image of $G$ under the mapping becomes a subgraph of the extended graph.

We first consider mappings into the existing vertices of $H$.
Let $V_G = \{1,\dots,n_G\}$ and $V_H = \{1,\dots,n_H\}$ with $n_G \leq n_H$.
An injective mapping $f : V_G \to V_H$ can be represented as an ordered $n_G$-tuple of distinct vertices of $H$.
For each such mapping we evaluate the \emph{deficit} of edges:
\[
  \mathrm{deficit}(f) = \left|\left\{ \{u,v\} \in E_G \;\middle|\; \{f(u), f(v)\} \notin E_H \right\}\right|.
\]
This quantity counts how many edges would need to be added to $H$ (between existing vertices) in order for the image of $G$ under $f$ to be realized as a subgraph of the extended graph.
The minimal deficit over all injective mappings into $V_H$ gives the minimal number of edge insertions required if we restrict ourselves to not adding new vertices.

If adding new vertices is allowed, the search space becomes even larger, since we may choose to map some vertices of $G$ to newly created vertices.
One possible exact strategy is then:
\begin{enumerate}
  \item For each integer $m \geq 0$ representing the number of new vertices to add, construct a hypothetical vertex set $V_H \cup V_{\mathrm{new}}$ with $|V_{\mathrm{new}}| = m$.
  \item Enumerate all injective mappings $f : V_G \to V_H \cup V_{\mathrm{new}}$.
  \item For each mapping compute the number of required edge insertions and count how many of them involve new vertices.
  \item Keep track of the mapping that minimizes the total number of inserted vertices and edges.
\end{enumerate}
The minimal total number of vertex and edge insertions over all considered values of $m$ gives the exact solution to the minimal extension problem.

The worst-case complexity of this exhaustive approach is clearly exponential.
Even if we restrict ourselves to mappings into the existing vertices of $H$, the number of injective mappings is
\[
  P(n_H, n_G) = \frac{n_H!}{(n_H - n_G)!},
\]
which grows superpolynomially in $n_H$ when $n_G$ is proportional to $n_H$.
For each mapping we must check all edges in $E_G$, which takes $O(|E_G|)$ time, or $O(n_G^2)$ in the worst case.
The overall worst-case time complexity is therefore
\[
  O\!\left(P(n_H, n_G) \cdot n_G^2\right),
\]
which is exponential in the size of the input graphs.

Because of this exponential behavior, exact algorithms for the minimal extension problem are practical only for very small graphs.
This observation motivates the design of approximate algorithms with polynomial-time complexity, as presented next.


\section{Approximation Algorithms}
\label{sec:approx}

Exact algorithms for graph edit distance and the minimal extension problem are computationally expensive and do not scale to larger graphs.
In this section we describe approximation ideas that replace the exponential search space of exact formulations by tractable optimization problems.
In particular, for GED we use a linear programming relaxation (F2LP) of a binary linear formulation from the literature, which yields a polynomial-time computable lower bound.

\subsection{Approximate GED via LP Relaxation (F2LP)}
\label{subsec:approx-ged}

Instead of approximating GED via bipartite matching, we use the continuous relaxation of the binary linear programming formulation \emph{F2} proposed by Lerouge et al.\ \cite{lerougeBLP}.
In that work, \emph{F2LP} denotes the linear program obtained from \emph{F2} by relaxing all binary constraints to continuous bounds in $[0,1]$.
Solving \emph{F2LP} yields a polynomial-time computable \emph{lower bound} on the exact GED, and we use this value as our approximation.

Let $G_1=(V_1,E_1)$ and $G_2=(V_2,E_2)$ be two (simple, undirected) graphs.
We introduce decision variables:
\begin{itemize}
  \item $x_{i,k} \in [0,1]$ for each $(i,k)\in V_1\times V_2$, indicating to what extent vertex $i$ of $G_1$ is matched to vertex $k$ of $G_2$,
  \item $y_{e,f} \in [0,1]$ for each $(e,f)\in E_1\times E_2$, indicating to what extent edge $e$ of $G_1$ is matched to edge $f$ of $G_2$.
\end{itemize}

The \emph{F2} objective can be written as a constant corresponding to ``delete and insert everything'', plus correction terms for chosen substitutions:
\[
  \min_{x,y}\;\; C
  + \sum_{i\in V_1}\sum_{k\in V_2}\bigl(c_V(i\!\rightarrow\! k)-c_V(i\!\rightarrow\!\epsilon)-c_V(\epsilon\!\rightarrow\! k)\bigr)\,x_{i,k}
  + \sum_{e\in E_1}\sum_{f\in E_2}\bigl(c_E(e\!\rightarrow\! f)-c_E(e\!\rightarrow\!\epsilon)-c_E(\epsilon\!\rightarrow\! f)\bigr)\,y_{e,f}.
\]
In our experiments we use unit insertion/deletion costs and zero substitution costs for unlabeled graphs, so $C = |V_1|+|V_2|+|E_1|+|E_2|$, and matching vertices/edges decreases the objective accordingly.

The constraints enforce that $x$ behaves like a partial one-to-one assignment, and that $y$ is consistent with $x$:
\begin{align*}
  \sum_{k\in V_2} x_{i,k} &\le 1 && \forall i\in V_1,\\
  \sum_{i\in V_1} x_{i,k} &\le 1 && \forall k\in V_2,\\
  \sum_{f\in E_2} y_{e,f} &\le 1 && \forall e\in E_1,\\
  \sum_{e\in E_1} y_{e,f} &\le 1 && \forall f\in E_2,\\
  \sum_{f\in E_2:\; k\in f} y_{\{i,j\},f} &\le x_{i,k} + x_{j,k} && \forall \{i,j\}\in E_1,\;\forall k\in V_2,\\
  0 \le x_{i,k} \le 1,\;\; 0 \le y_{e,f} \le 1. &&
\end{align*}

The last family of constraints is the (undirected) \emph{edge consistency} condition: an edge $\{i,j\}\in E_1$ may be matched to an edge incident to $k\in V_2$ only if (at least) one of its endpoints is matched to $k$.
Replacing integrality ($\{0,1\}$) by bounds ($[0,1]$) gives the LP relaxation \emph{F2LP}, which can be solved efficiently by standard LP solvers.
The optimum value of \emph{F2LP} is a lower bound on the exact GED \cite{lerougeBLP}, and we report it as our polynomial-time approximation.

\subsection{Approximate Minimal Extension}
\label{subsec:approx-extension}

The minimal extension problem can be approximated using a similar matching-based idea.
Intuitively, we use the approximate vertex correspondence between the pattern graph $G$ and the base graph $H$ to estimate how many vertices and edges must be added to $H$ so that it contains a subgraph that is structurally close to $G$.

We first run the approximate GED algorithm between $G$ and $H$ and obtain a vertex mapping $f : V_G \to V_H \cup \{\bot\}$ inferred from the optimal assignment.
Vertices $u \in V_G$ with $f(u) = \bot$ are interpreted as requiring the insertion of a corresponding new vertex in the extended graph $H'$.
Let $V_{\mathrm{ins}} = \{u \in V_G \mid f(u) = \bot\}$ denote the set of such vertices, and let $k_V = |V_{\mathrm{ins}}|$ be their number.
We add $k_V$ new vertices to $H$ to obtain a provisional extended vertex set.

Next we approximate the number of edges that must be added.
For each edge $\{u,v\} \in E_G$ we consider the images $f(u)$ and $f(v)$:
\begin{itemize}
  \item If both $f(u)$ and $f(v)$ are real vertices in $H$, we check whether $\{f(u),f(v)\} \in E_H$.
        If not, we count one missing edge between existing vertices.
  \item If at least one of $f(u)$ or $f(v)$ is mapped to $\bot$, we interpret this as requiring the insertion of an edge involving at least one newly added vertex.
\end{itemize}
Let $k_E$ denote the total number of such missing edges.
We then define the approximate extension cost as
\[
  \widehat{\Delta}(H,H') = k_V + k_E,
\]
where $k_V$ is the number of inserted vertices and $k_E$ is the number of inserted edges implied by the mapping $f$.
Note that the exact placement of the new vertices and edges in $H'$ can be reconstructed in a straightforward way from the mapping and the structure of $G$.

Importantly, the complexity of this approximate extension algorithm is dominated by the cost of computing the initial approximate GED.
The additional counting of missing vertices and edges requires only $O(|V_G| + |E_G|)$ time, which is at most quadratic in the number of vertices of $G$.
Thus the overall time complexity remains polynomial, with a cubic leading term due to the Hungarian algorithm.

\subsection{Discussion of Approximation Quality}
\label{subsec:approx-discussion}

The matching-based approach described above does not guarantee that the obtained value $\widehat{\mathrm{GED}}(G,H)$ equals the true graph edit distance, nor that the estimated extension cost $\widehat{\Delta}(H,H')$ is minimal.
The main source of approximation error is the locality of the cost matrix construction: the matching cost of two vertices is computed based on local information (labels, degrees, neighborhoods), whereas the global structure of the graphs may require more complex transformations.

Nevertheless, several practical advantages justify this approach:
\begin{itemize}
  \item The algorithm has polynomial worst-case complexity and can therefore handle graphs of significantly larger size than exact methods.
  \item The assignment-based correspondence typically captures a reasonable structural alignment between the graphs, especially when their local neighborhoods are informative.
  \item On small instances where the exact GED or exact minimal extension can be computed, empirical studies often show that the approximation is close to the true value \cite{riesen2009,lerougeBLP}.
\end{itemize}

In our experimental evaluation (Section~\ref{sec:experiments}) we compare the runtime and, where possible, the accuracy of the approximate methods against exact reference values.
The results confirm the expected trade-off: exact algorithms yield ground-truth distances but become infeasible beyond small graph sizes, while the approximate algorithms scale to larger inputs at the price of a moderate approximation error.

\section{Experimental Evaluation}
%(c) – wyniki testów czasowych itd.

\subsection{Input Size Measures}
% - Jak definiujemy "rozmiar zadania":
%   * |V(G)|, |E(G)|,
%   * size(G) według naszej definicji,
%   * może wspólny rozmiar pary (G,H).

\subsection{Runtime of Exact and Approximate Methods}
% - Tabele / wykresy:
%   * czas obliczeń exact GED dla małych grafów,
%   * czas approx GED dla większych grafów,
%   * ewentualne porównanie z zewnętrznym narzędziem (np. GEM++).

\subsection{Approximation Accuracy}
%   * porównanie approximate GED z exact GED na małych instancjach,
%   * statystyki błędu (średni, maksymalny).

\subsection{Discussion}
% - Interpretacja wyników:
%   * gdzie exact jest praktycznie wykonalny, a gdzie nie,
%   * skalowanie approx z rozmiarem grafu,
%   * kompromis między czasem a dokładnością.

\section{Implementation and Usage}
% opis techniczny programu.

\subsection{Software Architecture}
% - Krótki opis modułów:
%   * wczytywanie danych,
%   * implementacja exact GED (jeśli zaimplementowana),
%   * implementacja approx GED,
%   * moduł generowania raportów / wyników.

\subsection{Running the Program}
% - Przykłady uruchomienia:
%   * format linii poleceń,
%   * opis parametrów (tryb exact/approx, ścieżki do plików),
%   * opis formatu wypisywanych wyników.

\section{Conclusions}
% Ta sekcja odpowiada punktowi (e) – wnioski końcowe.
% - Podsumowanie osiągnięć:
%   * zdefiniowane pojęcia, zaproponowane algorytmy, implementacja,
%   * najważniejsze obserwacje z eksperymentów.
% - Ograniczenia obecnego podejścia.
% - Propozycje przyszłych prac (lepsze heurystyki, rozszerzenie na multigrafy itd.).

\section*{References}
\begin{thebibliography}{9}

\bibitem{riesen2009}
P.~Riesen and H.~Bunke,
\emph{Approximate graph edit distance computation by means of bipartite graph matching},
Image and Vision Computing, 2009.

\bibitem{lerougeBLP}
J.~Lerouge, Z.~Abu-Aisheh, R.~Raveaux, P.~H{\'e}roux, and S.~Adam,
\emph{Graph edit distance: A new binary linear programming formulation},
Pattern Recognition Letters, 2015.

\end{thebibliography}

\end{document}
