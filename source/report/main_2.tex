\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{float}
\geometry{margin=2.5cm}

\title{Graph Distance and Minimal Extension\\
  \large Algorithms and Computability – Project Report}
\author{Borkowicz Dominik \and Volkau Kiryl \and Włodarczyk Wiktoria }
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

Graphs are a standard model for discrete structures such as communication
networks, social networks or molecular structures. The project considers two
finite simple undirected graphs $G_1$ and $G_2$ given by adjacency matrices
and focuses on three questions:
\begin{itemize}
  \item how to quantify the \emph{size} of a graph in a way that reflects
        algorithmic difficulty,
  \item how to define a \emph{distance} between graphs,
  \item how many vertices and edges must be added to $G_2$ so that it contains
        a prescribed number of subgraphs isomorphic to $G_1$.
\end{itemize}
The implementation is based on Integer Linear Programming (ILP) and the GLPK
solver and supports both exact and relaxed formulations of these problems.

\section{Modelling assumptions and basic definitions}

\subsection{Graph model and input representation}

We work with \emph{finite simple undirected graphs} without loops and without
multiple edges. A graph is a pair
\[
G = (V(G), E(G)),
\]
where
\begin{itemize}
  \item $V(G)$ is a finite set of vertices,
  \item $E(G) \subseteq \{\{u,v\} : u,v \in V(G), u \neq v\}$ is a set of
        undirected edges.
\end{itemize}

For an edge $e = \{u,v\} \in E(G)$ the vertices $u$ and $v$ are adjacent. The
\emph{degree} of a vertex $v$, denoted $\deg_G(v)$, is the number of edges
incident to $v$.

Both graphs used in the assignment, the \emph{pattern} $G_1$ and the
\emph{host} $G_2$, are given as text files containing their adjacency matrices:
\begin{itemize}
  \item the first line of the file contains the number of vertices $n = |V(G)|$,
  \item the next $n$ lines contain the rows of the $n \times n$ adjacency
        matrix,
  \item entries in each row are separated by single spaces.
\end{itemize}

For simple undirected graphs the adjacency matrix $A$ satisfies:
\begin{itemize}
  \item $A_{ij} = A_{ji}$ for all $1 \le i,j \le n$ (symmetry),
  \item $A_{ii} = 0$ for all $1 \le i \le n$ (no loops),
  \item $A_{ij} = 1$ if and only if $\{i,j\} \in E(G)$.
\end{itemize}

Vertices are implicitly identified with the indices $\{1,\dots,n\}$ of the
rows and columns of the matrix. Two different files may represent isomorphic
graphs even if they use different vertex numbering.

\subsection{Size of a graph}

In standard graph theory the \emph{order} of a graph is the number of vertices
$|V(G)|$, and the \emph{edge size} is the number of edges $|E(G)|$. Here a
single scalar is used to reflect how large and complex an instance is from an
algorithmic point of view.

\textbf{Definition 2.1 (Graph size).}
For a finite simple graph $G$ the \emph{size} is
\[
\|G\| = |V(G)| + |E(G)|.
\]

\subsubsection*{Justification}

The definition has several useful properties:

\begin{enumerate}
  \item \textbf{Non-negativity and normalisation.} For any graph $G$,
        $|V(G)|,|E(G)| \ge 0$, hence $\|G\| \ge 0$ and $\|\emptyset\| = 0$.
  \item \textbf{Monotonicity under extensions.} If $G$ is a subgraph of $H$,
        then $|V(G)| \le |V(H)|$ and $|E(G)| \le |E(H)|$, so $\|G\| \le \|H\|$.
  \item \textbf{Additivity for disjoint unions.} If $G_1$ and $G_2$ are
        vertex-disjoint, then
        \[
          \|G_1 \cup G_2\| = \|G_1\| + \|G_2\|.
        \]
  \item \textbf{Relevance for computational complexity.} For sparse graphs
        $|E(G)|$ is of the same order as $|V(G)|$, while for dense graphs
        $|E(G)|$ can be quadratic in $|V(G)|$. The quantity
        $|V(G)| + |E(G)|$ is close to the size of the input and naturally
        appears in complexity bounds.
\end{enumerate}

\subsection{Distance between graphs: graph edit distance}

A metric on the set of all finite simple graphs should quantify how many local
changes are needed to transform one graph into another.

Let $\mathcal{G}$ denote the set of all finite simple graphs. A function
\[
d : \mathcal{G} \times \mathcal{G} \to \mathbb{R}_{\ge 0}
\]
is a \emph{metric} if for all $F,G,H \in \mathcal{G}$:
\begin{enumerate}
  \item $d(G,H) \ge 0$ (non-negativity),
  \item $d(G,H) = 0$ if and only if $G$ and $H$ are isomorphic,
  \item $d(G,H) = d(H,G)$,
  \item $d(F,H) \le d(F,G) + d(G,H)$.
\end{enumerate}

\subsubsection{Edit operations}

The following edit operations on graphs are considered:
\begin{enumerate}
  \item \emph{Vertex insertion}: add a new isolated vertex.
  \item \emph{Vertex deletion}: remove an existing vertex and all incident
        edges.
  \item \emph{Edge insertion}: add a new edge between two non-adjacent
        vertices.
  \item \emph{Edge deletion}: remove an existing edge.
\end{enumerate}

Each operation $e$ has a non-negative cost $c(e)$. In the basic setting
constant costs are used:
\begin{itemize}
  \item $c_v > 0$ for vertex insertion and deletion,
  \item $c_e > 0$ for edge insertion and deletion.
\end{itemize}

An \emph{edit path} from a graph $G$ to a graph $H$ is a finite sequence of
edit operations that transforms $G$ into a graph isomorphic to $H$. Its cost is
\[
C(P) = \sum_{i=1}^k c(e_i).
\]

\subsubsection{Definition of graph edit distance}

For two graphs $G$ and $H$ the \emph{graph edit distance} is
\[
d_{\mathrm{GED}}(G,H)
= \min\{ C(P) : P \text{ is an edit path from } G \text{ to } H \}.
\]

Under the above assumptions on the cost function, $d_{\mathrm{GED}}$ satisfies
the metric axioms:

\begin{itemize}
  \item \textbf{Non-negativity} follows from non-negative individual costs.
  \item \textbf{Identity of indiscernibles:} for isomorphic graphs an empty
        edit path has cost $0$, and if $d_{\mathrm{GED}}(G,H)=0$ then no edits
        are needed, so the graphs must be isomorphic.
  \item \textbf{Symmetry} holds because every edit operation has an inverse
        with the same cost.
  \item \textbf{Triangle inequality} holds because concatenating optimal edit
        paths from $F$ to $G$ and from $G$ to $H$ yields an edit path from $F$
        to $H$ whose cost is at least $d_{\mathrm{GED}}(F,H)$.
\end{itemize}

\subsection{Isomorphism and subgraphs}

\textbf{Definition 2.2 (Graph isomorphism).}
Two graphs $G = (V(G),E(G))$ and $H = (V(H),E(H))$ are \emph{isomorphic} if
there exists a bijection
\[
\varphi : V(G) \to V(H)
\]
such that for all $u,v \in V(G)$,
\[
\{u,v\} \in E(G) \quad \text{iff} \quad
\{\varphi(u),\varphi(v)\} \in E(H).
\]

\textbf{Definition 2.3 (Subgraph).}
A graph $G$ is a \emph{subgraph} of a graph $H$ (written $G \subseteq H$) if
\begin{itemize}
  \item $V(G) \subseteq V(H)$,
  \item $E(G) \subseteq E(H)$.
\end{itemize}

The graph $H$ \emph{contains a subgraph isomorphic to $G$} if there exists an
injective mapping $\varphi : V(G) \to V(H)$ such that the image of $G$ under
$\varphi$ is a subgraph of $H$ and is isomorphic to $G$. Subgraphs are not
assumed to be induced.

\subsection{Minimal extension containing isomorphic copies}

Let $G_1$ be the pattern graph and $G_2$ the host graph. Let $k \ge 1$ be the
required number of copies of $G_1$.

\textbf{Definition 2.4 (Extension of a graph).}
A graph $H$ is an \emph{extension} of $G_2$ if $G_2$ is a subgraph of $H$:
\begin{itemize}
  \item $V(G_2) \subseteq V(H)$,
  \item $E(G_2) \subseteq E(H)$.
\end{itemize}
Only extensions obtained by adding vertices and/or edges are considered.

\textbf{Definition 2.5 (Copies of $G_1$ in an extension).}
An \emph{isomorphic copy of $G_1$ in $H$} is a subgraph $F \subseteq H$ such
that $F \cong G_1$. The graph $H$ contains \emph{at least $k$ copies of $G_1$}
if there exist subgraphs $F_1,\dots,F_k \subseteq H$ with $F_i \cong G_1$ for
all $i$; the copies may overlap.

\textbf{Definition 2.6 (Minimal extension).}
Among all graphs $H$ that satisfy:
\begin{enumerate}
  \item $H$ is an extension of $G_2$,
  \item $H$ contains at least $k$ subgraphs isomorphic to $G_1$,
\end{enumerate}
a \emph{minimal extension} is any graph $H^{*}$ that minimises $\|H\|$:
\[
H^{*} \in \arg\min \Big\{ \|H\| : H \text{ is an extension of } G_2
\text{ and contains at least } k \text{ copies of } G_1 \Big\}.
\]

In the code we focus on the case $k=1$.

\section{Algorithms and implementation}
\label{sec:algorithms}

The program \texttt{gempp} takes two graphs in the adjacency-matrix format and
can operate in three modes:

\begin{itemize}
  \item \textbf{Minimal extension mode} (default): compute the minimal
        extension of the target graph $G_2$ such that the pattern graph $G_1$
        becomes its subgraph. Implemented as a Minimum Cost Subgraph Matching
        (MCSM) ILP.
  \item \textbf{GED mode} (\texttt{--ged}): compute the exact graph edit
        distance between $G_1$ and $G_2$ using an ILP formulation.
  \item \textbf{F2LP mode} (\texttt{--ged --f2lp}): solve the linear
        relaxation of the GED ILP, obtaining a polynomial-time lower bound on
        the GED.
\end{itemize}

\subsection{Graph parsing and representation}

Graph parsing is implemented in the \texttt{AdjacencyMatrixParser} class
(\texttt{src/model/adjacency\_parser.h}). Conceptually, the parser performs:

\begin{verbatim}
procedure ParseTwoGraphs(path):
  open file at 'path'
  read integer n1
  read n1 x n1 integers into matrix A1
  construct pattern graph G1 from A1
  read integer n2
  read n2 x n2 integers into matrix A2
  construct target graph G2 from A2
  return (G1, G2)
\end{verbatim}

Each matrix row is checked for the correct number of entries, entries are
required to be non-negative integers, and for undirected graphs symmetry
$A_{ij} = A_{ji}$ is verified. The matrices are then converted into internal
\texttt{Graph} objects with explicit vertices and edges.

\paragraph{Complexity.}
For a graph with $n$ vertices the parser reads $O(n^2)$ integers and performs
$O(1)$ work per entry. The time complexity is $O(n^2)$ and the memory usage is
$O(n^2)$ for the matrix plus $O(n + m)$ for vertex and edge objects, where $m$
is the number of edges.

\subsection{ILP formulation for minimal extension (MCSM)}

In the default mode the program uses the
\texttt{MinimumCostSubgraphMatching} formulation
(\texttt{src/formulation/mcsm.h}). The pattern graph is
$G_1 = (V_1, E_1)$ and the target graph is $G_2 = (V_2, E_2)$.

The ILP introduces two families of binary variables:
\begin{itemize}
  \item $x_{i,k} \in \{0,1\}$ for $i \in V_1$, $k \in V_2$:
        $x_{i,k} = 1$ if pattern vertex $i$ is matched to target vertex $k$,
  \item $y_{ij,kl} \in \{0,1\}$ for $ij \in E_1$, $kl \in E_2$:
        $y_{ij,kl} = 1$ if pattern edge $ij$ is matched to target edge $kl$.
\end{itemize}

Constraints enforce a consistent partial subgraph isomorphism:

\begin{itemize}
  \item each pattern vertex matches at most one target vertex:
        \[
          \forall i \in V_1:\quad \sum_{k \in V_2} x_{i,k} \le 1;
        \]
  \item each target vertex is used at most once:
        \[
          \forall k \in V_2:\quad \sum_{i \in V_1} x_{i,k} \le 1;
        \]
  \item each pattern edge and each target edge participates in at most one
        match;
  \item if $y_{ij,kl} = 1$ then the endpoints of edge $ij$ must be matched to
        the endpoints of edge $kl$:
        \[
          y_{ij,kl} \le x_{i,k}, \qquad y_{ij,kl} \le x_{j,l}.
        \]
\end{itemize}

The objective minimises the number of pattern vertices and edges that cannot be
mapped into the target:
\[
  \min \left[
    \sum_{i \in V_1} \left( 1 - \sum_{k \in V_2} x_{i,k} \right)
    +
    \sum_{ij \in E_1} \left( 1 - \sum_{kl \in E_2} y_{ij,kl} \right)
  \right].
\]

The behaviour of the solver can be summarised as:

\begin{verbatim}
procedure MinimalExtension(G1, G2):
  build MCSM ILP model with variables x_{i,k}, y_{ij,kl}
  add matching and consistency constraints
  set objective to minimise unmatched vertices and edges
  solve model with ILP solver
  from optimal x_{i,k}, y_{ij,kl}:
      collect unmatched vertices of G1
      collect unmatched edges of G1
  return (objective_value, unmatched_vertices, unmatched_edges)
\end{verbatim}

\paragraph{Complexity.}
The number of vertex variables is $|V_1| \cdot |V_2|$, and the number of edge
variables is $|E_1| \cdot |E_2|$. The ILP therefore has
$O(|V_1||V_2| + |E_1||E_2|)$ variables and constraints. Solving an ILP is
NP-hard in general and GLPK uses branch-and-bound and cutting planes, so the
worst-case running time is exponential in the input size.

\subsection{ILP formulation for graph edit distance}

With the \texttt{--ged} flag the program uses the
\texttt{LinearGraphEditDistance} formulation
(\texttt{src/formulation/linear\_ged.h}). The same types of variables
$x_{i,k}$ and $y_{ij,kl}$ are used, but the constraints enforce a full edit
mapping rather than a partial subgraph embedding.

Each pattern vertex either matches exactly one target vertex or is deleted.
Each target vertex either matches exactly one pattern vertex or is inserted.
Edges are treated analogously. Vertex and edge deletions and insertions are
represented implicitly by unmatched vertices and edges on each side.

The objective counts all edit operations. With unit costs it equals the number
of vertex deletions, vertex insertions, edge deletions and edge insertions, and
coincides with $d_{\mathrm{GED}}(G_1,G_2)$.

In pseudocode:

\begin{verbatim}
procedure ExactGED(G1, G2):
  build GED ILP model with variables x_{i,k}, y_{ij,kl}
  add constraints for substitutions, deletions and insertions
  set objective to total edit cost (vertices + edges)
  solve model with ILP solver
  let obj be the optimal objective value
  return obj  // exact GED
\end{verbatim}

\paragraph{Complexity.}
The number of variables and constraints is of the same order as in the MCSM
formulation. The worst-case complexity of solving the ILP is again exponential.

\subsection{F2 linear relaxation (polynomial lower bound)}

With both \texttt{--ged} and \texttt{--f2lp} enabled the program solves the
linear relaxation of the GED ILP (F2 formulation). The model structure and
objective remain the same, but all variables $x_{i,k}$ and $y_{ij,kl}$ are
relaxed to continuous values in $[0,1]$.

\begin{verbatim}
procedure GED_LowerBound_F2LP(G1, G2):
  build GED ILP model as in ExactGED
  relax all variables to continuous domain [0,1]
  solve resulting Linear Program with LP solver
  return optimal objective value  // lower bound on GED
\end{verbatim}

The resulting value satisfies
\[
  \text{F2LP}(G_1,G_2) \le d_{\mathrm{GED}}(G_1,G_2)
\]
and can be computed in polynomial time using linear programming.

\paragraph{Complexity.}
The F2LP formulation has the same numbers of variables and constraints as the
GED ILP. Linear programming is solvable in polynomial time and GLPK’s
simplex-based implementation is fast for the moderate instance sizes used in
the experiments.

\subsection{Command-line interface and usage}

The \texttt{main} function parses command-line arguments and selects the mode.
The usage message printed when no input file is given is:

\begin{verbatim}
Usage: ./gempp [--time] <input_file.txt>

Input format: text file with two graphs (pattern and target)
  First graph (pattern):
    Line 1: number of vertices
    Following lines: adjacency matrix (0 or 1)
  Second graph (target):
    Line 1: number of vertices
    Following lines: adjacency matrix (0 or 1)

Options:
  --time, -t    Show computation time in milliseconds
  --ged, -g     Solve full graph edit distance (default: minimal extension)
  --f2lp, --lp  Solve GED using the F2 linear relaxation (lower bound)
  --up,  -u v   Upper-bound pruning parameter in (0,1] for GED
  --output, -o  Write solution XML to the given file (GEM++ style)
\end{verbatim}

High-level logic:

\begin{verbatim}
procedure Main(input_file, options):
  (G1, G2) = ParseTwoGraphs(input_file)
  if options.mode == "minimal extension":
      (ext_value, Uv, Ue) = MinimalExtension(G1, G2)
      print ext_value, Uv, Ue and optional time
  else if options.mode == "GED":
      if options.relaxed:
          ged_lb = GED_LowerBound_F2LP(G1, G2)
          print ged_lb and optional time
      else:
          ged = ExactGED(G1, G2)
          print ged and optional time
\end{verbatim}

\section{Experimental evaluation}
\label{sec:experiments}

\subsection{Test environment}

Benchmarks were executed using the \texttt{gempp} executable in Release mode,
with the GLPK~5.0 solver bundled in the project. The setup was:

\begin{itemize}
  \item macOS and Windows on standard desktop / laptop hardware,
  \item C++17 compiler with optimisation enabled,
  \item GLPK 5.0 as the ILP/LP solver,
  \item running time measured with the \texttt{--time} option (milliseconds).
\end{itemize}

The focus is on trends in running time as a function of graph size and
structure, rather than on absolute timings.

\subsection{Benchmark families}

The benchmark suite in \texttt{docs/REPORT.md} covers:

\begin{itemize}
  \item complete graphs $K_n$,
  \item path graphs $P_n$,
  \item cycle graphs $C_n$.
\end{itemize}

For each pair $(G_1,G_2)$ the program computes the graph edit distance
$d_{\mathrm{GED}}(G_1,G_2)$ and, in extension mode, the number of edges that
must be added so that $G_1$ becomes a subgraph of the extended $G_2$.

\subsubsection{Complete graph in complete graph ($K_n$ in $K_m$)}

These are exact subgraph cases (GED $= 0$). 
\begin{table}[H]
\centering
\begin{tabular}{l l r r}
\toprule
Pattern & Target & Time [ms] & GED \\
\midrule
$K_3$ & $K_4$ & 1 & 0 \\
$K_3$ & $K_5$ & 0 & 0 \\
$K_3$ & $K_6$ & 0 & 0 \\
$K_3$ & $K_7$ & 1 & 0 \\
$K_3$ & $K_8$ & 1 & 0 \\
$K_4$ & $K_4$ & 0 & 0 \\
$K_4$ & $K_5$ & 1 & 0 \\
$K_4$ & $K_6$ & 1 & 0 \\
$K_4$ & $K_7$ & 3 & 0 \\
$K_4$ & $K_8$ & 1 & 0 \\
$K_5$ & $K_5$ & 3 & 0 \\
$K_5$ & $K_6$ & 1 & 0 \\
$K_5$ & $K_7$ & 11 & 0 \\
$K_5$ & $K_8$ & 2 & 0 \\
\bottomrule
\end{tabular}
\caption{Complete graph in complete graph benchmarks ($K_n$ in $K_m$).}
\label{tab:kn-km}
\end{table}

\subsubsection{Path graph in path graph ($P_n$ in $P_m$)}

Here both pattern and target are sparse; all instances have GED $=0$.

\begin{table}[H]
\centering
\begin{tabular}{l l r r}
\toprule
Pattern & Target & Time [ms] & GED \\
\midrule
$P_3$ & $P_5$  & 0  & 0 \\
$P_3$ & $P_{10}$ & 0  & 0 \\
$P_4$ & $P_5$  & 1  & 0 \\
$P_4$ & $P_{10}$ & 1  & 0 \\
$P_5$ & $P_5$  & 1  & 0 \\
$P_5$ & $P_{10}$ & 2  & 0 \\
$P_6$ & $P_6$  & 3  & 0 \\
$P_6$ & $P_{10}$ & 32 & 0 \\
\bottomrule
\end{tabular}
\caption{Path graph in path graph benchmarks ($P_n$ in $P_m$).}
\label{tab:pn-pm}
\end{table}

\subsubsection{Cycle graph in complete graph ($C_n$ in $K_m$)}

Cycle graphs are embedded into complete graphs; again GED $=0$ in all tested
cases.

\begin{table}[H]
\centering
\begin{tabular}{l l r r}
\toprule
Pattern & Target & Time [ms] & GED \\
\midrule
$C_3$ & $K_4$ & 0  & 0 \\
$C_3$ & $K_8$ & 1  & 0 \\
$C_4$ & $K_4$ & 0  & 0 \\
$C_4$ & $K_8$ & 2  & 0 \\
$C_5$ & $K_5$ & 1  & 0 \\
$C_5$ & $K_8$ & 2  & 0 \\
$C_6$ & $K_6$ & 1  & 0 \\
$C_6$ & $K_8$ & 11 & 0 \\
\bottomrule
\end{tabular}
\caption{Cycle graph in complete graph benchmarks ($C_n$ in $K_m$).}
\label{tab:cn-km}
\end{table}

\subsubsection{Complete graph in path graph ($K_n$ in $P_m$)}

These cases require adding edges to the path graph (GED $> 0$); they directly
illustrate the minimal extension concept.

\begin{table}[H]
\centering
\begin{tabular}{l l r r r}
\toprule
Pattern & Target & Time [ms] & GED & Edges to add \\
\midrule
$K_3$ & $P_5$   &    2 & 1 & 1 \\
$K_3$ & $P_{10}$ &   15 & 1 & 1 \\
$K_4$ & $P_5$   &   13 & 3 & 3 \\
$K_4$ & $P_{10}$ &  279 & 3 & 3 \\
$K_5$ & $P_5$   &  106 & 6 & 6 \\
$K_5$ & $P_{10}$ & 3951 & 6 & 6 \\
\bottomrule
\end{tabular}
\caption{Complete graph in path graph benchmarks ($K_n$ in $P_m$),
extension of the target required.}
\label{tab:kn-pm}
\end{table}

\subsubsection{Large graph stress test ($K_n$ in $K_n$)}

The stress test in \texttt{REPORT.md} summarises running times for larger
complete graphs:

\begin{table}[H]
\centering
\begin{tabular}{l r l}
\toprule
Size & Time [ms] & Notes \\
\midrule
$K_8$  &     62   & fast \\
$K_{10}$ &    518   & $< 1$ second \\
$K_{12}$ &  21732  & $\approx 22$ seconds \\
$K_{15}$ & 229735  & $\approx 4$ minutes \\
\bottomrule
\end{tabular}
\caption{Large graph stress test ($K_n$ in $K_n$).}
\label{tab:stress}
\end{table}

In the corresponding GED formulation the number of ILP variables is on the
order of $|V_1||V_2| + |E_1||E_2|$, which for complete graphs grows
quadratically in $n$ and explains the steep growth in solving time.

\subsection{Correctness verification}

The project includes 15 unit tests covering:
\begin{itemize}
  \item exact subgraph matches with GED $= 0$,
  \item edge extension cases (only edges added),
  \item vertex extension cases (vertices added),
  \item motifs such as triangles, squares, paths, stars, complete graphs and
        cycles.
\end{itemize}
All tests pass, which supports the correctness of the parser and ILP
formulations on small, hand-crafted examples.

\subsection{Performance summary}

From the tables above:

\begin{itemize}
  \item Exact subgraph cases (Tables~\ref{tab:kn-km},
        \ref{tab:pn-pm}, \ref{tab:cn-km}) are solved very quickly
        for the tested sizes; GED is zero and the solver only needs to confirm
        an embedding.
  \item Extension cases (Table~\ref{tab:kn-pm}) show that both the GED and
        the number of edges to add grow with the pattern size, and the running
        time grows from milliseconds to several seconds even for a fixed
        target size $|V_2|=10$.
  \item The stress test (Table~\ref{tab:stress}) shows that dense graphs with
        12--15 vertices already lead to solving times of tens of seconds to a
        few minutes.
\end{itemize}

Overall, exact ILP-based methods are practical for small and medium graphs; for
dense graphs with more than about a dozen vertices, the exponential worst-case
behaviour becomes visible.

\section{Conclusions}

The work combines graph-theoretic concepts with an ILP-based implementation:

\begin{itemize}
  \item Graph size is defined as $\|G\| = |V(G)| + |E(G)|$, which aligns with
        the adjacency-matrix input size and is monotone under extensions.
  \item Graph edit distance $d_{\mathrm{GED}}$ is used as a metric on graphs
        and implemented via an ILP that counts vertex and edge insertions and
        deletions.
  \item Minimal extension is realised as a Minimum Cost Subgraph Matching
        problem, where the objective is the number of pattern vertices and
        edges that must be created in the target.
\end{itemize}

The experiments show two main regimes:

\begin{itemize}
  \item For graphs up to roughly 8--10 vertices (including dense complete
        graphs) the exact ILP solver is fast enough for interactive use.
  \item For dense graphs of size 12--15 the number of ILP variables and the
        solving time increase rapidly, reaching tens of seconds or minutes,
        which matches the theoretical hardness of subgraph isomorphism and
        GED.
\end{itemize}

\subsection*{Limitations}

The current solution has several clear limitations:

\begin{itemize}
  \item \textbf{Instance size.} The ILP formulation does not scale beyond
        small and medium graphs. For dense graphs with more than about
        15 vertices the solver becomes impractically slow.
  \item \textbf{Graph model.} Only simple, undirected, unlabelled graphs are
        supported. There is no handling of vertex or edge labels, directed
        edges, or multigraphs.
  \item \textbf{Edit cost model.} All edit operations have unit cost. More
        refined cost models (e.g.\ different penalties for vertex vs.\ edge
        edits) are not exposed in the command-line interface.
  \item \textbf{Minimal extension parameter $k$.} The implementation focuses on
        $k=1$ (one copy of the pattern). Multiple required copies would need
        additional constraints in the ILP.
  \item \textbf{Approximation in practice.} The F2LP relaxation is implemented
        but not fully explored in the benchmarks, and there are no additional
        heuristic algorithms (greedy, local search) to handle larger graphs.
\end{itemize}



\begin{thebibliography}{9}

\bibitem{Bunke1997}
H.~Bunke.
\newblock On a relation between graph edit distance and maximum common
  subgraph.
\newblock {\em Pattern Recognition Letters}, 18(8):689--694, 1997.

\bibitem{RiesenBunke2009}
K.~Riesen and H.~Bunke.
\newblock Approximate graph edit distance computation by means of bipartite
  graph matching.
\newblock {\em Image and Vision Computing}, 27(7):950--959, 2009.

\bibitem{Solnon2015}
C.~Solnon, G.~Damiand, C.~de~la Higuera, and J.-C.~Janodet.
\newblock On the complexity of submap isomorphism and maximum common submap
  problems.
\newblock {\em Pattern Recognition}, 48(2):302--316, 2015.

\end{thebibliography}


\end{document}
